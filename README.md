## 二分搜索

要点：source 按顺序排列，可比大小。

代码要点：注意while 循环的终止条件和mid +/-1

复杂度：O(logn)

顺序匹配搜索：O(n)

## 选择排序

要点：双循环，内循环每次选择一个最大or最小值，并同时删除该值。

复杂度:O(n*n)

## 快速排序



要点：分而治之思想，先找出最简单的情况（0个或1个数组元素），再增加一点复杂度（两个元素数组）的情况如何处理。任意找到一个基准点值，根据小于和大于这个值将数组分成两个数组，把这两个数组放入方法递归使他们排好序然后拼接 smaller,基准值，bigger=>最终为从小到大排列的数组。

复杂度：递归调用的广度和深度O(nlogn)

## 广度优先搜索

要点：从一个root节点开始，优先递归子节点，如果一个子节点不是目标，把这个子节点的子节点数组添加到搜索数组当中。

复杂度：O(V+N)，n节点数，V链接的边数